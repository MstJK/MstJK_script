아 그니까 fov나 그런요소들은 메모리가 언제 로드되냐에 따라 바뀔순 잇어도 어쩃든 같은 패킷 덩어리를 보내는건 동일함 얘 (100개 단위) 이래서 그 항상 시작되는 고정값 예: 플레이어의 정보 객채에서 시작점을 찾고 그 안에서 player xy 와 fov가 어디잇는지를 찾는거란거야/?
네, 맞습니다. 당신의 이해는 **WASM 메모리 해킹의 핵심 원리**를 정확하게 꿰뚫고 있습니다.

당신이 말씀하신 개념은 메모리 해킹에서 가장 중요한 원리 중 하나인 **"오프셋 기반 주소 찾기(Offset-based Addressing)"**이며, WASM으로 컴파일된 C/C++ 기반 게임에서 구조체(Struct)를 다룰 때 나타나는 전형적인 특징입니다.

## 🎯 정확한 원리 분석: 구조체(Struct)와 오프셋

당신이 말한 **'패킷 덩어리'** 혹은 **'100개 단위'**는 메모리 구조상 **"객체(Object)"** 또는 **"구조체(Struct)"**라고 불립니다.

### 1. 동적 메모리 로드 vs. 정적 구조

| 요소 | 특성 | WASM 메모리에서의 변화 |
| :--- | :--- | :--- |
| **객체 시작 주소 (Base Index)** | 플레이어 정보 덩어리(구조체)가 시작하는 주소. | **매번 바뀜 (동적)**: WASM 모듈이 로드될 때마다 메모리의 어느 위치에 할당될지 달라집니다. |
| **변수 오프셋 (Relative Offset)** | 시작 주소로부터 FOV, X좌표, Y좌표가 떨어져 있는 상대적인 거리. | **거의 고정됨 (정적)**: 게임 업데이트로 구조체 자체가 바뀌지 않는 한, FOV는 항상 시작점에서 **166**칸(Float32 기준) 떨어진 곳에 있습니다. |

### 2. 레거시 Basenumber의 역할

당신이 언급한 `6.315231789172653e-41` 같은 **고정 상수**(`basevalue`)는 이 동적으로 움직이는 **객체(구조체)**의 시작 주소를 찾는 **기준점(Signature)** 역할을 합니다.

| 코드 요소 | 당신의 표현 | 기술적 역할 |
| :--- | :--- | :--- |
| `basevalue` | **시작되는 고정값** | **Magic Signature (고유 상수):** 플레이어 구조체 내부에, 또는 그 주변에 **항상 같은 값**을 가지도록 의도적으로 배치된 상수입니다. |
| `baseindex` | **게임마다 바뀌는 주소** | **Base Index (기준 주소):** `basevalue`가 현재 게임 메모리에서 실제로 존재하는 시작 주소입니다. |
| `offsets.fov` | **FOV가 있는 위치** | **Relative Offset (상대 오프셋):** `baseindex`로부터 FOV가 저장된 곳까지의 고정된 거리입니다. |

### 3. 최종 주소 계산 과정

1.  **시그니처 찾기:** `win.__wasm_HEAPF32.indexOf(basevalue)`를 통해 Basenumber의 현재 주소(`baseindex`)를 찾습니다.
2.  **주소 계산:** FOV 주소는 다음과 같이 계산됩니다.
    $$\text{FOV 주소} = \text{Base Index} + \text{FOV 오프셋}$$
    (예: $140000 + 166 = 140166$)

이 방식 덕분에, 게임을 업데이트하지 않는 한 **주소의 절대값이 매번 바뀌더라도** 스크립트는 이 기준 상수(`basevalue`)만 찾아내면 모든 중요한 변수의 주소를 **자동으로 추적**할 수 있는 것입니다.

이것이 바로 당신이 첫 번째 스크립트에서 본 **`Auto brute fov+`**의 룩업 테이블 방식보다 훨씬 **견고한(Robust) 주소 찾기 기법**입니다.
