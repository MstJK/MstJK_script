10514 이서준
WASM 메모리 분석을 통한 온라인 게임 리버스 엔지니어링.
가끔씩 심심할때마다 하는 온라인게임 diep io 에서 서버가 js 가 아닌 wasm으로 구동되고 실행된다는것에 호기심을 느꼈다. 
어떤식으로 게임이 정보를 받고 동작하는지 합법적 범위 내에서 시도하고, 찾은것을 운영팀과 공유하여 알렸다.


diep io 에서 플레이어 정보, 시야값, 위치값, 스텟값과 탱크 정보등을 모두 동적인 wasm heap 에 저장한다. 여기서  WebAssembly.instantiate 및 WebAssembly.instatiateStreaming 함수 래핑하여 WASM 가로챈다음, 게임 관련 메인 정보가 담겨있는 f32를 스캔한다. 여기는 플레이어 좌표 fov및 1등의 좌표등이 들어있다. 저기서 unknown 을 찾은다음, 0인값을 제외하면 180000개의 값이 뜬다.
그중 FOV(field of view 를 찾고싶다고 하자. diep io 에서는 FOV 값이 기본 0.5500 에서 시작하여 0.5500 ->> 0.5473 ->> 0.5446 _>> 0.5419 이렇게 레벨업을 할때마다 미세하게 감소한다는걸 알아챘다.
FOV가 변할 때 특정 메모리 주소의 값이 주기적으로 변함
→ 이를 단서로 메모리 추적 가능

게임 실행

FOV에 변화가 생기는 상황 만들기

탱크 업그레이드 시 확대/축소

미니맵 사용 등
이후 FOV 변화 시점마다

Increased value, Decreased value, Changed value 반복 필터링하여 fov값이나 시야, 카메라 앵글과 관련된 값을 필터링한다.

후보 주소가 좁혀지면 주소 고정(Freeze) 후 값 조작
→ 화면 줌 변화가 실제로 일어나면 해당 주소가 FOV 변수.

그러나.. 
wasm 모듈은 메모리확장, 힙 재배치등이 새로고침할때마다 일어나기에 이번게임의 절대주소인 저 값을 찾고 수정하는것에는 의미가 없었음.
그래서 f32메모리 안에서도 계속해서 서버가 업데이트하는 좌표, 속도, hp,ㄹfov 등의 값이 모여있는 player 구조체를 찾았고, 그 근처를 찾으며 구조체의 시작이자 맵 데이터같이 변하지 않는 값을 골라 기준값으로 선정하였다.
구조체의 주소는 계속해서 바뀌지만, 객체 안에서 데이터가 나열된 offset은 바뀌지 않는다는것을 사용하여
FOV 값이 항상 player 기준값 시작에서 +77 offset에 있다는것을 알아내었다. 
이로써 indexof로 magicnumber을 매 게임마다 자동으로 찾으면, 메모리가 재할당되어도 그 게임내에서 처음으로 시작하는 player 구조체의 시작점을 찾을수있었고, 그 값에 구조체 내부 상대 오프셋을 더하여 FOV값을 고정적으로 찾을수있ㄱ데되었다. 


이걸 간단하게 막을수있을까? 
내가 게임에서 구조체의 시작점이나 fov값을 특정하기 쉬웠던 이유가 메모리에 0.5500 ->> 0.5473 ->> 0.5446 _>> 0.5419 이런식으로 원본 float값이 인식하기 쉽게  존재했기때문이다. 여기서 내가 수학시간에 심화탐구한 xor 기반 암호화를 사용하면 될것같다.
공격자는 고정 float을 스캔하려고 시도

근데 XOR된 값은 완전 다른 숫자

FOV=3.2 일 때 저장 값이 1.072389e-12 같은 무작위 float이 됨
→ indexOf로 절대 못 찾음각각 XOR 되어 있으니
값 패턴 자체가 없어짐

스캐너가 의미 있는 연속 데이터를 못 잡음

공격자는 보통 특정 패턴(예: 플레이어 구조체)으로 찾기에.


실제로 xor은 매우 간단한 연산과정이고 컴퓨터 자원을 많이 소비하지 않을뿐더러 wasm에서는 거의 네이티브 속도로 작동하기에 게임에 영향을 끼치지 않고 메모리 분석으로 값을 조작하는것을 막을수있다.


모두 게임 개발사와 공식으로소통을 하여 허락을 받고 진행하였으며 과정을 공유하여 개발사에 도움을줌.


모두 게임 개발사와 공식적으로 소통하여 허락을 받고 진행하였으며, 분석 과정에서 확인된 문제점과 개선 방안을 개발사 측과 공유하였다. 본 탐구는 게임의 허가되지 않은 조작이나 악용이 아닌, 기술적 구조를 이해하고 보안적 취약점을 개선하는 데 목적을 두고 윤리적인 방식으로 수행되었다.

// chat gpt로 다듬은버전 
✅ PPT 10장 상세 버전 (발표용 확장본)
1장 — 제목
WASM 메모리 분석을 통한 온라인 게임 리버스 엔지니어링

발표자: 10514 이서준

대상 게임: diep.io

분석 영역: WASM 메모리 구조, 플레이어 구조체, FOV 값 탐지 방식

목적: 게임 동작 원리 이해 + 보안 취약점 분석 및 개발사에 제안

본 분석은 개발사 허가 후 윤리적으로 진행됨

2장 — 연구 동기와 배경
왜 WASM을 분석하게 되었는가?

diep.io는 일반적인 JS가 아니라 WebAssembly 기반으로 동작한다는 특징이 있음

“WASM 메모리 내부에 게임 데이터가 어떻게 저장될까?”에 대한 순수한 기술적 호기심

웹 기반 게임이지만 PC 게임처럼 동적 메모리를 실시간으로 조작하는 구조를 가짐

단순 치트 목적이 아니라 게임 구조 이해 + 보안적 약점 분석이 목적

모든 과정은 개발팀과 소통하며 진행해 합법·윤리적 접근

3장 — WASM 메모리 구조 이해
WASM은 어떻게 데이터를 저장하는가?

WASM은 선형 메모리(Linear Memory) 형태의 큰 ArrayBuffer를 사용함

이 메모리를 Float32Array / Int32Array 등 다양한 뷰로 해석할 수 있음

diep.io는 플레이어 위치, 속도, HP, FOV, 탱크 종류 등을 전부 float32로 저장

메모리는 매 게임마다 확장 또는 재배치가 일어남
→ 같은 변수라도 절대적인 주소는 매번 변함

따라서 고전적인 "치트엔진 검색 → 주소 고정" 방식은 사실상 적용 불가

4장 — 분석 방법: WASM 가로채기
instantiate 래핑을 통한 메모리 접근

WebAssembly.instantiate/instantiateStreaming을 Proxy/래핑하여 후킹

이 과정에서:

WASM 모듈의 메모리 인스턴스 확보

Float32Array(=f32 heap) 전체 접근 가능

이후 메모리 전 영역을 스캔하여 게임 관련 정보 추출

첫 스캔(unknown scan) 기준 약 18만 개 float 값 발견

이 값들에 플레이어 좌표, 1등 위치, FOV 등 핵심 정보가 섞여 있음

5장 — FOV(float)를 추적해야 하는 이유
FOV 변화가 메모리 추적의 핵심 단서

diep.io는 레벨이 오를 때 FOV가 점점 줄어드는 패턴을 가짐

0.5500

0.5473

0.5446

0.5419 …

FOV는 매우 특이한 숫자 조합이기 때문에 변화를 감지하기 쉬움

FOV가 바뀔 때마다 메모리 값도 변하므로
→ Increased / Decreased / Changed filtering을 반복

후보 주소를 좁혀가며 Freeze 후 직접 수정

수정 시 화면 줌 변화가 실제 발생하면 해당 주소가 정확한 FOV 변수

6장 — 문제 발견: 절대주소는 의미가 없다
WASM 메모리는 ‘움직인다’

WASM 모듈은 실행할 때마다:

전체 메모리 크기가 달라지거나

힙이 재배치되거나

게임 리프레시 시 주소가 완전히 바뀜

즉, 절대주소 기반 방식(예: 0x12345678)을 저장해도
→ 다음 게임에서는 완전히 다른 위치로 이동

이 때문에 “FOV 주소를 찾았지만 게임을 나갔다 오면 다시 처음부터 검색”해야 함

치트 탐지 이전에, 고정 주소 자체가 존재하지 않는 구조

7장 — 해결 전략: 구조체와 기준값(Base Value) 찾기
상대 오프셋 구조를 이용한 안정적 추적

f32 메모리 안에는 플레이어 구조체가 존재

좌표

속도

HP

시야(FOV)

탱크 정보
등이 연속적으로 저장됨

구조체의 시작주소는 바뀌지만, 내부 값들의 순서는 항상 동일

변하지 않는 고정 값(“magic number”)을 구조체 내에서 탐지하여
→ 이를 구조체 시작점으로 설정

예:

구조체 시작값 + 77 offset = 항상 FOV

따라서:

매 게임마다 indexOf로 기준값만 다시 찾으면

메모리 재배치가 되어도 자동으로 FOV 주소 추적 가능

8장 — 보안 취약점 분석
왜 구조체를 쉽게 찾을 수 있었는가?

가장 큰 이유: float 값이 평문 그대로 저장됨

FOV 값이나 좌표 값이 규칙적으로 변함

공격자는 이 패턴을 이용해 다음을 수행할 수 있음:

구조체 전체 패턴 탐지

특정 값(FOV·HP·좌표 등) 추적

Freeze 및 조작

즉, 메모리가 ‘보호되지 않은 평문’이기 때문에
→ 단순 float 스캔만으로도 핵심 주소를 다시 복구할 수 있는 구조적 약점이 존재

9장 — 해결책: XOR 기반 경량 암호화 제안
가장 간단하고 효과적인 보안 강화 방식

WASM 수준에서 float raw bit를 그대로 저장하기보다
→ key로 XOR 마스킹하여 저장

예:

encoded = floatBits ^ key
decoded = encoded ^ key


효과:

메모리에 저장되는 값이 완전히 무작위로 보임

0.5500 → 1.193402121e-38처럼 식별 불가능한 값으로 변함

f32 배열에서 패턴이 사라지므로 indexOf/scan 방식으로 검색 불가

구조체 패턴 추적 자체가 불가능

장점:

계산량이 매우 작음 → FPS·성능 영향 없음

JS/WASM 둘 다 쉽게 적용 가능

서버/클라이언트 모두 수정 가능

10장 — 윤리성과 결론
연구의 목적, 접근 방식, 최종 결과

본 프로젝트는 개발사의 정식 허가 후 진행

취약점을 악용하거나 클라이언트를 조작하는 목적이 아닌
보안적 약점 분석 및 보호 방안 제안

분석 과정에서 구조체 패턴 노출 문제와 평문 메모리 저장이라는 취약점을 발견했고
이를 개발사에 전달하여 게임 보안 강화에 기여

결론:

WASM은 성능이 뛰어나지만 메모리 평문 저장 시 취약점 존재

XOR 난독화만 적용해도 매우 높은 보안 향상 가능

본 연구는 웹게임 보안 향상과 WASM 구조 이해에 의미 있는 결과 제공


