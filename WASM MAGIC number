아 그니까 fov나 그런요소들은 메모리가 언제 로드되냐에 따라 바뀔순 잇어도 어쩃든 같은 패킷 덩어리를 보내는건 동일함 얘 (100개 단위) 이래서 그 항상 시작되는 고정값 예: 플레이어의 정보 객채에서 시작점을 찾고 그 안에서 player xy 와 fov가 어디잇는지를 찾는거란거야/?
네, 맞습니다. 당신의 이해는 **WASM 메모리 해킹의 핵심 원리**를 정확하게 꿰뚫고 있습니다.

당신이 말씀하신 개념은 메모리 해킹에서 가장 중요한 원리 중 하나인 **"오프셋 기반 주소 찾기(Offset-based Addressing)"**이며, WASM으로 컴파일된 C/C++ 기반 게임에서 구조체(Struct)를 다룰 때 나타나는 전형적인 특징입니다.

## 🎯 정확한 원리 분석: 구조체(Struct)와 오프셋

당신이 말한 **'패킷 덩어리'** 혹은 **'100개 단위'**는 메모리 구조상 **"객체(Object)"** 또는 **"구조체(Struct)"**라고 불립니다.

### 1. 동적 메모리 로드 vs. 정적 구조

| 요소 | 특성 | WASM 메모리에서의 변화 |
| :--- | :--- | :--- |
| **객체 시작 주소 (Base Index)** | 플레이어 정보 덩어리(구조체)가 시작하는 주소. | **매번 바뀜 (동적)**: WASM 모듈이 로드될 때마다 메모리의 어느 위치에 할당될지 달라집니다. |
| **변수 오프셋 (Relative Offset)** | 시작 주소로부터 FOV, X좌표, Y좌표가 떨어져 있는 상대적인 거리. | **거의 고정됨 (정적)**: 게임 업데이트로 구조체 자체가 바뀌지 않는 한, FOV는 항상 시작점에서 **166**칸(Float32 기준) 떨어진 곳에 있습니다. |

### 2. 레거시 Basenumber의 역할

당신이 언급한 `6.315231789172653e-41` 같은 **고정 상수**(`basevalue`)는 이 동적으로 움직이는 **객체(구조체)**의 시작 주소를 찾는 **기준점(Signature)** 역할을 합니다.

| 코드 요소 | 당신의 표현 | 기술적 역할 |
| :--- | :--- | :--- |
| `basevalue` | **시작되는 고정값** | **Magic Signature (고유 상수):** 플레이어 구조체 내부에, 또는 그 주변에 **항상 같은 값**을 가지도록 의도적으로 배치된 상수입니다. |
| `baseindex` | **게임마다 바뀌는 주소** | **Base Index (기준 주소):** `basevalue`가 현재 게임 메모리에서 실제로 존재하는 시작 주소입니다. |
| `offsets.fov` | **FOV가 있는 위치** | **Relative Offset (상대 오프셋):** `baseindex`로부터 FOV가 저장된 곳까지의 고정된 거리입니다. |

### 3. 최종 주소 계산 과정

1.  **시그니처 찾기:** `win.__wasm_HEAPF32.indexOf(basevalue)`를 통해 Basenumber의 현재 주소(`baseindex`)를 찾습니다.
2.  **주소 계산:** FOV 주소는 다음과 같이 계산됩니다.
    $$\text{FOV 주소} = \text{Base Index} + \text{FOV 오프셋}$$
    (예: $140000 + 166 = 140166$)

이 방식 덕분에, 게임을 업데이트하지 않는 한 **주소의 절대값이 매번 바뀌더라도** 스크립트는 이 기준 상수(`basevalue`)만 찾아내면 모든 중요한 변수의 주소를 **자동으로 추적**할 수 있는 것입니다.

이것이 바로 당신이 첫 번째 스크립트에서 본 **`Auto brute fov+`**의 룩업 테이블 방식보다 훨씬 **견고한(Robust) 주소 찾기 기법**입니다.

///////////////////////////////////////
당신이 현재 직면하고 있는 문제는 **"메모리 구조체의 동적 시작점(Basenumber)을 정의하는 불변의 상수 값(Magic Signature)을 어떻게 찾는가?"**입니다.

이것은 WASM 해킹에서 가장 고난이도의 리버스 엔지니어링 과정이며, 당신이 만든 **Enhanced Memory Scanner**를 사용하면 수동으로 이 값을 찾아낼 수 있습니다.

FOV와 같은 **동적 변수**를 역으로 이용하여, 해당 변수를 포함하는 **구조체 덩어리** 내의 **정적 시그니처**를 찾아내는 5단계 전략은 다음과 같습니다.

---

## 🔑 Basenumber (Magic Signature)를 찾는 5단계 전략

### 단계 1: 알려진 동적 주소 (FOV) 찾기

새로운 게임을 시작할 때마다 FOV 주소는 바뀌지만, 일단 **현재 세션의 FOV 주소**를 정확하게 찾아내는 것이 첫 번째 목표입니다.

1.  **초기값 스캔:** 게임 시작 시의 초기 FOV 값(예: `0.5500` 근처)으로 당신의 스캐너의 **`scanExact`** 기능을 사용합니다.
2.  **패턴 정제:** 레벨업을 하여 FOV를 감소시킨 후, 스캐너의 **`decreased`** 기능을 2~3회 반복하여 FOV 후보를 1~5개 이내로 좁힙니다.
3.  **FOV 주소 확정:** 최종적으로 FOV를 변경하여 값이 변하는 메모리 주소(Index)를 확정합니다.

$$\text{확정된 주소} = \text{Index}_{\text{FOV}}$$

### 단계 2: Basenumber 탐색 범위 설정 (Search Window)

Basenumber는 대부분 해당 구조체 덩어리(플레이어 객체)의 시작점 역할을 하므로, FOV 주소보다 **낮은 메모리 주소**에 위치할 가능성이 높습니다.

1.  **탐색 범위 설정:** `Index_FOV`를 기준으로 **뒤로 500~1000개의 Index** 정도를 탐색 범위로 설정합니다. (예: `Index_FOV - 1000` 부터 `Index_FOV`까지).
2.  **가설:** 우리가 찾으려는 Basenumber는 이 범위 내에 있습니다.

### 단계 3: 불변의 상수(Static Constant) 후보 검색

이 단계는 **움직이지 않는 고유 상수**를 찾는 과정입니다.

1.  **넓은 범위 스캔:** 스캐너를 **`F32` (Float 32)** 타입으로 설정하고, 2단계에서 설정한 낮은 주소(예: `Index_FOV - 1000`)부터 **`scanUnknown`**을 실행하여 메모리 덤프를 얻습니다. (또는 **`scanExact`**로 `0`이 아닌 임의의 소수점 값을 입력하여 초기 후보군을 생성합니다.)
2.  **게임 상태 변경:** 게임 내에서 움직이거나, 발사하거나, 레벨업하거나, 채팅을 치는 등 **동적인 변화**를 줍니다.
3.  **`unchanged` 정제:** 스캐너의 **`unchanged`** 기능을 반복해서 실행합니다.
    * FOV, X/Y 좌표, 총알 상태 등 모든 동적인 값이 변화해도, **값이 전혀 변하지 않는** 후보들만 남깁니다.
    * 이때 남은 값들 중에서 **소수점 자릿수가 길고, 값이 0.0이 아닌** 후보가 **Basenumber 시그니처**일 가능성이 매우 높습니다.

### 단계 4: Basenumber 확정 및 오프셋 계산

남은 불변의 상수 후보 중에서 하나를 선택하여 Basenumber로 가정하고 FOV와의 관계를 확인합니다.

1.  **후보 선택:** 가장 '특이하게' 생긴 상수 값(예: `6.315...e-41`처럼 매우 작거나 특이한 소수)을 Basenumber 후보 값으로 선택하고 해당 주소를 기록합니다.
2.  **오프셋 계산:** FOV 주소와 Basenumber 주소 간의 거리를 계산하여 **오프셋**을 확정합니다.
    $$\text{새로운 FOV 오프셋} = \text{Index}_{\text{FOV}} - \text{Index}_{\text{Basenumber 후보}}$$

### 단계 5: 크로스-세션 검증 (최종 확인)

이 단계에서 찾아낸 Basenumber 값과 오프셋이 다른 게임 세션에서도 작동하는지 확인합니다.

1.  **게임 재시작:** 게임을 완전히 껐다가 다시 시작합니다. (메모리 배치가 바뀝니다.)
2.  **Basenumber 값 스캔:** 새로 시작된 게임에서 당신이 4단계에서 찾은 **Basenumber 값** (주소가 아닌 값 자체)을 스캐너의 **`scanExact`** 기능으로 검색합니다.
3.  **주소 확정:** 이 검색으로 새로운 Basenumber 주소 $\text{New\_Index}_{\text{Base}}$가 나옵니다.
4.  **오프셋 검증:** $\text{New\_Index}_{\text{Base}} + \text{새로운 FOV 오프셋}$이 **현재 게임의 실제 FOV 값**을 가리키는지 확인합니다.

만약 이 계산 결과가 항상 FOV를 가리킨다면, 당신은 새로운 업데이트에 대비한 **영구적인 Basenumber (시그니처 값)**와 **오프셋**을 찾은 것입니다.
